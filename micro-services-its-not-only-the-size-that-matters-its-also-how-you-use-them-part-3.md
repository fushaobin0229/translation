Microservices: It’s not (only) the size that matters, it’s (also) how you use them – part 3

> https://www.tigerteam.dk/2014/micro-services-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-3/

前文中，我们再次描述服务（微服务）之间进行双向同步通信的问题，我们讨论了微服务使用双向同步通信造成的耦合问题实际上是分布式对象的一种变形。我们还谈及这种缺乏可信任的消息和事务导致服务失败时复杂的补偿逻辑。

重温了 8 个分布式计算谬论后，我们开始寻找双向通信调用服务的替换方案，从 Pat Hellands 的 "Life Beyond Distributed Transactions ? – An Apostate ‘s Opinion" 一文中我们看到分布式事务并不是协调服务更新操作的解决方案，分布式事务是有问题的。

根据 Pat Hellands 所言，我们必须解决一下问题：

怎么拆分数据和服务
怎样发现数据和服务
数据服务间如何通信

前两个问题我们在前文中已经谈及，可以归纳为：

数据必须被组织成实体或聚合（DDD 术语）
聚合必须有唯一可标识的 ID（比如 UUID/GUID）
聚合需要限定大小以保证事务一致性
经验法则是：1 usercase = 1 transaction = 1 aggregate

下面我们继续说第三个问题

数据服务间如何通信

前面说了多次，服务间使用双向同步通信导致深度耦合和其他烦恼：

  通信相关的耦合（数据和服务不总是在一个服务内），也导致通信合同、数据、功能性耦合以及网络通信高延迟
  分层耦合（业务和安全、持久化等不在一个服务内）
  临时耦合（当服务依赖的其他服务无法访问时服务不可用）
  服务依赖于其他服务，破坏了自治性和可靠性
  在没有可靠的消息需要复杂的逻辑补偿

![服务复用在双向同步通信方式下的耦合](http://www.tigerteam.dk/wp-content/uploads/2014/03/reusable-services-and-coupling.png)

如果同步通信不是办法，那么是不是应该用异步通信？

是的，但是取决于……
说取决于什么之前，我们先看看同步和异步通信的特点。

同步通信需要消费者和提供者通信发生时都在线，比如载入一个网页或者两个人对话。
异步通信的发送者和接收者不需要同时在线，异步通信方式打破了发送者和接收者之间的临时耦合，比如电子邮件、短信、邮寄。
基于这些特点，我们简单的对通信进行了分类：

同步通信是双向通信
![同步通信](http://www.tigerteam.dk/wp-content/uploads/2014/04/synchronous-communication.png)
上图的同步通信方式称为请求/应答模式，典型情况下以 PRC 模式实现。
在请求/应答模式下，服务消费者发送一个请求消息给服务提供者，在服务提供者处理请求消息时，服务消费者基本上只能等待直到收到应答或者发生错误。（有些人可能会说，消费者可以利用异步平台特性，在等待时并行的做其他调用，但这其实没有解决调用时消费者和提供者的临时耦合，在收到应答前消费者根本无法继续后面的工作。）电影的请求/应答或者说 RPC 调用流程如下图。

