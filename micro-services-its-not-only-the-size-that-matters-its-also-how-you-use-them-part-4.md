Microservices: It’s not (only) the size that matters, it’s (also) how you use them – part 4

> https://www.tigerteam.dk/2014/microservices-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-4/

第三部分我们谈到，为了确保我们的服务能高度自治，我们需要避免服务间的（同步）双向通信，而应该使用单向通信。

高度自治同时也意味着低耦合，耦合越少，服务和数据的版本问题也就越少。
我们还提高了服务的稳定性 -- 其他服务执行时发生的错误不会直接影响我们的服务。

但是，怎样才能完成工作，如果我们只使用单向通信，我们的服务怎么返回数据呢？
直接的回答是你不能，但是拥有良好定义的服务边界，你的服务就不需要直接调用其它服务来获取数据，大多数情况是这样。

## 服务边界

什么是服务边界？这个词基本上表示一个服务负责的业务数据和功能函数。在 "SOA: synchronous communication, data ownership and coupling" 一文中我们对服务原则，比如边界和自治有更详细的介绍。
边界确定了那些是服务的内部，那些是服务的外部，在本文第二部分我们使用了聚合模式去分析那些数据属于 Legal Entity Service 的内部。
在 Legal Entity Service 的例子中，我们意识到 LegalEntity 和 Address 的关系是属于关系，因为 LegalEntity 和它相关的 Address 是同时创建、修改和删除的。把两个服务合并成一个服务，Legal Entity Service 做到了自治，进而避免了调用服务时出现错误时，要对其他操作数据服务的调用做编排的复杂场景。

Legal Entity 耦合的问题可以被轻松解决，但是如果数据和数据见的关系更复杂怎么办？仅仅把这些数据堆到一个服务里避免跨处理边界的数据变革问题（比如不同的服务部署在不同的操作系统进程或者不同的物理服务器上），这样做的话很快我们就会被拉回 Monolith 版图，Monolith 本身没什么错，也可以使用许多相似的设计原则来构建 Monolith 应用，比如可以用模块来代替微服务，模块也可以一起打包后一起部署，就像微服务经常被独立部署一样（独立部署常常被认为是微服务带来的优点）。

## 模糊的边界 -- Monolith 走下坡路

Monolith 的一个问题是模糊边界的风险。因为模块是紧密绑定在一起的，常常在同一个代码库内，这样会造成一种缓慢恶化的倾向，导致了模块间越来越多的耦合，因为实在是太容易调用其它函数、组件或者 Join 其他表。

Monolith 感觉好极了，特别是在项目初期，问题很少，复杂度也不高，Monolith 还有一种趋势，会导致其以数据和功能逻辑的形式承担过多的职责。

开发 Monolith 应用时，你可以：

利用局部性，执行内存调用避免分布式事务；Join 处于同一个 DB 下的其他 SQL 表格。

还可以利用开发工具的重构、代码自动补全、代码查询等能力。

硬币的另一面是高耦合和低内聚的风险，Monolith 很容易慢慢的变得越来越大，因为他承担了太多的职责，因为太容易使用已有的功能和数据。

![Monolith 数据模型慢慢变大最终因为缺乏内聚而变得混乱](http://www.tigerteam.dk/wp-content/uploads/2014/02/model-growth.png)

这就是 Monolith 走下坡路：

![Monolith 随着复杂度下滑](http://www.tigerteam.dk/wp-content/uploads/2014/05/monolith-slippery-slope.png)

Monolith 还有几个劣势：

很难适应新技术 -- 要使用新的框架/语言/技术常常需要重写整个 Monolith 应用
重用行差 -- 功能部分不能单独重用
交付缓慢 -- 新功能引入需要协调其他功能一起发布
应用尺寸和职责越来越大
越来越高的耦合
启动要用很长时间
测试要用很长时间
Monolith 要求你的大脑要同时容纳大量的业务概念，而人对复杂度的掌控是有限的
可靠性 -- 一个业务除了问题（比如内存溢出）都会导致整个 Monolith 系统宕机

你可以在设计 Monolith 时定义内部的服务和组件并且定义好边界使他们保持松散的耦合，但是从我 20 多年的经验来看，使用这种模式的应用基本都是大泥球。

## 集成成堆的 Web Service

从我的经验来看许多公司实施 SOA 的方案是在已存在的 Monolith 系统上加上 Web Service，这种方式有其意义，可以使老的 Monolith 系统可被复用。

问题是大多数 Monolith 系统已经防战到了包含许多不同类型的业务。这意味着公司最终不得不有很多核心系统，这些系统拥有很多相似的业务数据，每种业务都没有真正的单一源头。

![Monolith 集成成堆的 Web Service](http://www.tigerteam.dk/wp-content/uploads/2014/05/integration-by-a-bunch-of-webservices.png)

如果我们刚接手一个 Monolith 系统，想要拆分成小一点的服务，我们还需要处理 Monolith 系统的内部耦合，典型的内部耦合包括集成、直接的方法调用、SQL Join 等等。如果我们只是简单的创建服务只会让事情更糟。

![Monolith 分拆成服务](http://www.tigerteam.dk/wp-content/uploads/2014/05/monolith-sliced-up-into-microservices.png)

所有这些都导致了模糊的服务边界，一些服务会很单薄并且会过度的依赖其他服务的数据和功能。在我看来，这不是松耦合，也许恰恰相反。

## 定义服务边界

当创建新服务或者从现有的 Monolith 分拆服务时，我们需要花时间定义服务的边界，所以我们可以避免使用服务间双向通信，除非 authority 比自治性更重要时，这些我们后面再说。
注意：高度自治并不是所有情况都需要的，可能有些场景使用双向通信时从开发角度看性价比更高，有些场景下缺乏自治是可以容忍的（比如跨越多个服务的读取）。

在旧的 Monolith 系统，我们可能已经收集了关于零售领域的所有的功能和数据，可能包含的功能区有，产品目录、销售、库存、配送、结账，每一个功能区可以被叫做子域或者业务功能：

![零售领域的功能区](http://www.tigerteam.dk/wp-content/uploads/2014/05/functional-areas.png)

零售业务就是销售产品，所以每个功能区或者说子域都会以一些方式牵扯到产品这个领域概念：

产品目录子域里面的产品包含名称、描述、图片等等。
销售子域会创建产品订单。
库存子域关心产品的库存数量（QOH），还有产品所在位置等，这里我们用 Product 这个名字，也可以不用，根据库存相关的项目/产品的状态，有时候也可以叫 Stock Item 或者 Back Ordered Item 等等。
价格子域关心产品的定价策略，可以包含根据客户状态的折扣（客户状态可能在另一个 CRM 大系统或服务里维护）。
配送子域关心产品的尺寸、重量以及发送目的地等。

如你所想，所有子域都跟产品发生了关联，子域可以给产品使用 Product 这个名字也可以使用不同的命名（其他的领域概念比如 Customer 也类似），关联在产品上不同的数据也很有意思，库存子域关心库存单元（SKU）、库存数量（QOH）、库存位置代码，对库存子域来说，商品名称、图片之类的可能不关心，即使有了，也只是给库存工人工作提供帮助，不会是处理库存业务必须的。
另一方面，配送子域不会关心库存数量（QOH）、库存位置代码等等，他们关心产品尺寸、重量，也许会关心商品名称，如果要打印配送收据的话。
不同视角的配送领域在领域驱动设计（DDD）里被称为不同的界限上下文（Bounded Context）。

在 Monolith 系统，很容易会创建一个 Product 表，包含许多的属性和关联，不同子域只是在他们认为合适的地方插入/更新或者关联数据，风险是 Product 领域模型会变大，造成该模型变化的业务会有很多（违反单一职责原则）导致耦合和一致性缺失。
因为其他业务依赖它，你不能修改 Product 表格结构，从托管代码到服务和服务合同的提升只是溢出了技术耦合，实际上服务人你果然需要其他服务的数据和功能，这将我们服务的自治性降低到不可接受的级别。

我们需要一种方法来设计服务边界，这样我们的服务就可以不需要为获取数据或者调用功能而使用双向通信方式来互相沟通。

我们可以围绕着功能区或者业务范围来开始服务构建，并用这个作为服务的边界，服务拥有自己的数据和功能。
别的服务不允许拥有这个服务的的数据。
数据只能有一个所有者，有了这个保证，我们相信我们的服务是他所有的业务数据的唯一事实来源。

这样做确保我们的服务只需要响应业务功能负责的修改，这就是服务的单一职责原则（SRP），你可以越多关于 SRP 的谈论[这篇](http://www.udidahan.com/2014/05/26/people-politics-and-the-single-responsibility-principle/)和[这篇](http://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)。

注意：下面的例子是构建更松散耦合服务之路的第一步，定义服务边界可不容易，后面的文章会深入到







