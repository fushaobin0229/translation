Microservices: It’s not (only) the size that matters, it’s (also) how you use them – part 4

> https://www.tigerteam.dk/2014/microservices-its-not-only-the-size-that-matters-its-also-how-you-use-them-part-4/

第三部分我们谈到，为了确保我们的服务能高度自治，我们需要避免服务间的（同步）双向通信，而应该使用单向通信。

高度自治同时也意味着低耦合，耦合越少，服务和数据的版本问题也就越少。
我们还提高了服务的稳定性 -- 其他服务执行时发生的错误不会直接影响我们的服务。

但是，怎样才能完成工作，如果我们只使用单向通信，我们的服务怎么返回数据呢？
直接的回答是你不能，但是拥有良好定义的服务边界，你的服务就不需要直接调用其它服务来获取数据，大多数情况是这样。

服务边界

什么是服务边界？这个词基本上表示一个服务负责的业务数据和功能函数。在 "SOA: synchronous communication, data ownership and coupling" 一文中我们对服务原则，比如边界和自治有更详细的介绍。
边界确定了那些是服务的内部，那些是服务的外部，在本文第二部分我们使用了聚合模式去分析那些数据属于 Legal Entity Service 的内部。
在 Legal Entity Service 的例子中，我们意识到 LegalEntity 和 Address 的关系是属于关系，因为 LegalEntity 和它相关的 Address 是同时创建、修改和删除的。把两个服务合并成一个服务，Legal Entity Service 做到了自治，进而避免了调用服务时出现错误时，要对其他操作数据服务的调用做编排的复杂场景。

Legal Entity 耦合的问题可以被轻松解决，但是如果数据和数据见的关系更复杂怎么办？仅仅把这些数据堆到一个服务里避免跨处理边界的数据变革问题（比如不同的服务部署在不同的操作系统进程或者不同的物理服务器上），这样做的话很快我们就会被拉回 monolith 版图，monolith 本身没什么错，也可以使用许多相似的设计原则来构建 monolith 应用，比如可以用模块来代替微服务，模块也可以一起打包后一起部署，就像微服务经常被独立部署一样（独立部署常常被认为是微服务带来的优点）。

模糊的边界 -- monolith 的滑坡

monolith 的一个问题是模糊边界的风险。因为模块是紧密绑定在一起的，常常在同一个代码库内，这样会造成一种缓慢恶化的倾向，导致了模块间越来越多的耦合，因为实在是太容易调用其它函数、组件或者 Join 其他表。

monolith 感觉好极了，特别是在项目初期，问题很少，复杂度也不高，monolith 还有一种趋势，回导致其以数据和功能逻辑的形式承担过多的职责。

开发 monolith 应用时，你可以：

利用局部性，执行内存调用避免分布式事务；关联处于同一个 DB 下的其他 SQL 表格。

还可以利用开发工具的重构、代码自动补全、代码查询等能力。
